\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{Panduan OSN Informatika berbasis Kurikulum 2017}
\author{William Gozali, Alham Fikri Aji}
\providecommand{\institute}[1]{}
\institute{Ikatan Alumni Tim Olimpiade Komputer Indonesia}
\date{}

\begin{document}
\maketitle
\begin{abstract}
Dokumen ini merupakan panduan persiapan Olimpiade Sains Nasional bidang informatika yang dirancang mengikuti kurikulum resmi 2017. Pada dokumen ini terdapat penjelasan singkat untuk tiap bab beserta referensi lanjutan, contoh soal, serta pembahasan.
\end{abstract}

{
halo

\setcounter{tocdepth}{3}
\tableofcontents
}
\subsection{Aritmetika dan aturan
berhitung}\label{aritmetika-dan-aturan-berhitung}

Aritmetika dan aturan berhitung melingkupi:

\begin{itemize}
\item ~
  \subsubsection{Aritmetika modular}\label{aritmetika-modular}

  Memahami konsep operasi modular. Operasi \(a \bmod m\), atau biasa
  disebut ``\(a\) modulo \(m\)'' memberikan sisa hasil bagi \(a\) oleh
  \(m\).
\item ~
  \subsubsection{Bilangan prima}\label{bilangan-prima}

  Bilangan prima adalah bilangan bulat positif yang hanya habis dibagi
  oleh 1 dan dirinya sendiri. Memahami algoritma-algoritma untuk
  mengecek bilangan prima, menghasilkan bilangan prima, ataupun
  melakukan faktorisasi prima.
\item ~
  \subsubsection{KPK dan FPB}\label{kpk-dan-fpb}

  Mencari KPK dan FPB dengan memanfaatkan faktorisasi prima.
\item ~
  \subsubsection{Pigeonhole Principle}\label{pigeonhole-principle}

  Konsep PHP menyatakan bahwa ``Jika ada \(N\) burung dan \(M\) sangkar,
  dimana \(N > M\) , maka ada sangkar yang berisi setidaknya 2 ekor
  burung''. Secara matematis, jika ada \(N\) burung dan \(M\) sangkar,
  maka ada sangkar yang berisi setidaknya
  \(\big\lceil \frac{N}{M} \big\rceil\) ekor burung.
\item ~
  \paragraph{Aturan perkalian dan
  penjumlahan}\label{aturan-perkalian-dan-penjumlahan}
\item ~
  \subsubsection{Permutasi dan kombinasi}\label{permutasi-dan-kombinasi}

  Permutasi dari \(N\) adalah seluruh cara pengurutan \(N\) objek
  tersebut. Banyaknya permutasi dari \(N\) dinyatakan dalam faktorial,
  atau \(N!\). Rumus faktorial, dinotasikan \(N!\) adalah hasil kali
  dari 1 sampai \(N\), sehingga
  \(N! = 1 \times 2 \times 3 \times \dots \times N\) Kombinasi adalah
  banyaknya cara mengambil \(K\) buah objek dari \(N\) pilihan yang ada,
  tanpa memerdulikan urutan. Notasi kombinasi ini dinyatakan dalam
  \(C^{N}_{K} = \).
\item ~
  \subsubsection{Probabilitas}\label{probabilitas}

  Menghitung kemungkinan terjadinya suatu persistiwa. Secara umum,
  probabilitas direpresentasikan dalam bentuk \(\frac{A}{B}\) dimana A
  adalah total cara terjadinya peristiwa yang diinginkan dan B adalah
  total cara terjadinya semua peristiwa. Sebagai contoh, jika terdapat
  \(N\) bola merah dan \(M\) bola biru, dan Anda mengambil tepat 2 bola
  secara acak, berapa kemungkinan bahwa kedua bola berwarna biru?
  Banyaknya cara mengambil 2 bola biru adalah \(C^{N}_{2} \) dan
  banyaknya cara mengambil 2 bola sembarang warna adalah \(C^{N+M}_2 \).
\item ~
  \subsubsection{Prinsip Inklusi dan
  Eksklusi}\label{prinsip-inklusi-dan-eksklusi}
\item ~
  \subsubsection{Segitiga Pascal}\label{segitiga-pascal}

  Segitiga Pascal merupakan susunan dari Koefisien Binomial dalam bentuk
  segitiga. Nilai dari baris ke-n suku ke-r adalah
  \(A_{ij} = C^{n}_{r}\).
\end{itemize}

Contoh soal:

\begin{quote}
Anda diberikan sebuah string S. Ada berapa kata berbeda yang dapat
disusun dari huruf-huruf penyusun kata S?

\begin{verbatim}
Contoh 1  : S = 'aba'. 
Jawaban 1 : 3 ('aab', 'aba', 'baa')

Contoh 2  : S = 'MEGAGIGA'
Jawaban 2 : 3360
\end{verbatim}
\end{quote}

Soal tersebut adalah soal kombinatorik. Mari kita selesaikan contoh 2
terlebih dahulu.

\begin{itemize}
\tightlist
\item
  Terdapat 8 huruf, sehingga banyak kata yang dapat disusun adalah
  \(8!\).
\item
  Terdapat 3 huruf `G' sehingga terdapat 6 kata yang kita anggap berbeda
  (
  \(G_{1} G_{2} G_{3} , G_{1} G_{3} G_{2} , \dots , G_{3} G_{2} G_{1} \)
  ) yang mana seharusnya keenam kata tersebut merupakan kata yang sama.
\item
  Dengan prinsip Redundansi, maka banyak kata yang dapat disusun
  mengingat kesamaan kata pada huruf G adalah \(\frac{8!}{3!}\).
\item
  Perlu kita perhatikan pula bahwa terdapat 2 huruf A, sehingga dengan
  cara yang sama akan didapatkan banyak kata yang berbeda adalah
  \(\frac{8!}{(3! \times 2!)} = 3360\).
\end{itemize}

Maka, solusi secara umum

\begin{itemize}
\tightlist
\item
  Terdapat N huruf, sehingga banyak kata yang dapat kita susun adalah
  \(N!\).
\item
  Apabila terdapat K huruf dengan setiap hurufnya memiliki \(R_{i}\)
  huruf yang sama, maka dengan prinsip Redundansi banyak kata berbeda
  yang dapat disusun adalah
  \(\frac{N!}{(R_{1}! \times R_{2}! \times R_{3}! \times â€¦ \times R_{K}!)}\).
\item
  Rumus itulah yang kita kenal dengan Permutasi Elemen Berulang.
\end{itemize}

\paragraph{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\tightlist
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/lessons/18/}{Materi
  Kombinatorik TLX Training Gate}
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/lessons/17/}{Materi
  Matematika Diskret TLX Training Gate}
\end{itemize}

\paragraph{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan}

\paragraph{TLX: Faktorisasi Prima}\label{tlx-faktorisasi-prima}

\begin{quote}
bla
\end{quote}

\paragraph{TLX: Penjumlahan Pecahan}\label{tlx-penjumlahan-pecahan}

\begin{quote}
bla
\end{quote}

\paragraph{TLX: Prima ke-K}\label{tlx-prima-ke-k}

\begin{quote}
bla
\end{quote}

\paragraph{TLX: Pasar Rakyat}\label{tlx-pasar-rakyat}

\begin{quote}
bla
\end{quote}

\paragraph{OSN 2006: Faktorial}\label{osn-2006-faktorial}

\begin{quote}
bla
\end{quote}

\paragraph{Codeforces: Random Teams}\label{codeforces-random-teams}

\begin{quote}
bla
\end{quote}

\subsection{Brute Force}\label{brute-force}

Brute-force merupakan suatu strategi penyelesaian masalah dengan mencoba
semua kemungkinan. Brute-force menjamin solusi selalu benar, namun
biasanya lambat karena menjelajahi semua kemungkinan solusi. Pada OSN,
Brute-force berguna untuk menguji kebenaran solusi utama kita. Selain
itu, biasanya tiap soal selalu memiliki sub-task yang bisa diselesaikan
dengan teknik Brute-force.

Contoh soal:

\begin{quote}
Anda diberikan sebuah array A yang terdiri dari N buah bilangan, dan
juga bilangan K. Apakah terdapat subset dari bilangan-bilangan tersebut
sehingga jumlahan dari elemen subset tersebut sama dengan K? item Bila
iya, maka keluarkan ``YA''. Selain itu keluarkan ``TIDAK''

\begin{verbatim}
Contoh  1 : A = [1, 3, 6, 10], K = 14
Jawaban 1 : "YA" (K = 1 + 3 + 10)

Contoh  2 : A = [1, 3, 6, 10], K = 15
Jawaban 2 : "TIDAK"
\end{verbatim}
\end{quote}

Solusi soal di atas adalah:

\begin{itemize}
\tightlist
\item
  Untuk setiap elemen, kita memiliki 2 pilihan yaitu memilih elemen
  tersebut atau tidak memilihnya.
\item
  Kita akan menelusuri semua kemungkinan pilihan.
\item
  Jika jumlahan dari elemen-elemen yang dipilih sama dengan

  , maka terdapat solusi.
\item
  Hal ini dapat dengan mudah diimplementasikan secara rekursif.
\end{itemize}

Mari kita analisa solusi tersebut. Terdapat

kemungkinan pilih-tidak pilih, sehingga kompleksitas solusi adalah

. Nilai

tumbuh dengan sangat cepat, sehingga solusi ini hanya dapat
menyelesaikan soal tersebut jika

kecil.

\subsection{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\tightlist
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/52/lessons/19/}{Materi
  Brute-Force TLX Training Gate}
\end{itemize}

\subsection{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan-1}

\subsection{Dynamic Programming}\label{dynamic-programming}

Dynamic Programming (DP) merupakan sebuah teknik dalam strategi
penyelesaian masalah. Seperti Greedy, suatu persoalan dapat diselesaikan
dengan teknik DP jika solusi optimal dari persoalan dapat ditentukan
dari solusi optimal sub-persoalan tersebut. Perbedaannya, pada DP,
sub-persoalan tersebut muncul berkali-kali di mana kita menyimpan solusi
optimal dari sub-persoalan tersebut dalam tabel. Untuk menguasai DP,
dibutuhkan banyak latihan soal. DP hampir selalu muncul dalam OSN
(Silahkan lihat contoh-contoh soal) dan sangat direkomendasikan untuk
Anda menguasai topik ini.

Contoh soal:

\begin{quote}
\begin{itemize}
\tightlist
\item
  Diberikan

  jenis koin, masing-masing jenis bernilai

  rupiah.
\item
  Asumsikan terdapat tak hingga koin untuk setiap nominal koin yang ada.
\item
  Tentukan berapa banyaknya minimum koin untuk membayar sebesar

  rupiah!
\end{itemize}

\begin{verbatim}
Contoh 1  : M = [1, 6, 10], N = 12
Jawaban 1 : 2 (6 + 6)
\end{verbatim}
\end{quote}

Soal tersebut adalah soal DP klasik ``Coin Change''. Mari perhatikan
properti berikut:

\begin{itemize}
\tightlist
\item
  Untuk membayar

  rupiah, kita dapat memilih salah satu koin terlebih dahulu.
\item
  Jika nilai koin itu adalah

  , maka sisa uang uang perlu kita bayar adalah

  .
\item
  Perhatikan bahwa penukaran

  merupakan suatu sub-persoalan yang serupa dengan persoalan awalnya.
  Artinya, cara yang sama untuk menyelesaikan sub-persoalan dapat
  digunakan.
\end{itemize}

Bagaimana menyelesaikan soal tersebut secara DP?

\begin{itemize}
\tightlist
\item
  Definisikan sebuah fungsi

  sebagai banyaknya koin minimum yang dibutuhkan untuk membayar

  rupiah.
\item
  Kita dapat mencoba-coba koin yang ingin kita gunakan.
\item
  Jika suatu koin

  digunakan, maka kita membutuhkan

  koin ditambah satu koin

  .
\item
  Atau dapat ditulis
\item
  Pencarian nilai

  dilakukan secara rekursif, kita kembali mencoba-coba koin yang ingin
  digunakan.
\item
  Fungsi

  ini akan dikunjungi berkali-kali! Sehingga nilai

  perlu kita simpan dalam tabel.
\end{itemize}

Ini adalah salah satu contoh permasalahan DP klasik. Untuk contoh-contoh
klasik lainnnya, bisa dilihat di Materi Contoh DP Klasik TLX Training
Gate berikut.

\subsection{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\tightlist
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/55/lessons/23/}{Materi
  Perkenalan DP TLX Training Gate}
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/55/lessons/24/}{Materi
  Studi Kasus DP TLX Training Gate}
\end{itemize}

\subsection{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan-2}

\subsection{Greedy}\label{greedy}

merupakan sebuah teknik dalam strategi penyelesaian masalah. Suatu
persoalan dapat diselesaikan dengan teknik Greedy jika persoalan
tersebut memiliki memiliki properti berikut:

\begin{itemize}
\tightlist
\item
  Solusi optimal dari persoalan dapat ditentukan dari solusi optimal
  sub-persoalan tersebut.
\item
  Pada setiap sub-persoalan, ada suatu langkah yang bisa dilakukan yang
  mana langkah tersebut menghasilkan solusi optimal pada sub-persoalan
  tersebut. Langkah ini disebut juga Greedy Choice.
\end{itemize}

Contoh soal:

\begin{quote}
Diberikan

buah aktivitas.

\begin{itemize}
\tightlist
\item
  Aktivitas ke-

  dinyatakan dalam

  .
\item
  Artinya, aktivitas ini dimulai pada waktu

  dan berakhir pada waktu

  .
\item
  Pada setiap satuan waktu, Anda dapat mengikuti paling banyak satu
  aktivitas.
\item
  Anda ingin mengatur jadwal sedemikian sehingga Anda bisa ikut
  aktivitas sebanyak mungkin.

\begin{verbatim}
Contoh  : aktifitas = [<1, 3> , <2, 6>, <5, 7>,  <8, 9>]
Jawaban : [<1, 3>, <5, 7>, <8, 9>]
\end{verbatim}
\end{itemize}
\end{quote}

Untuk menyelesaikan soal tersebut, kita lihat apakah soal tersebut dapat
dijadikan subsoal yang lebih kecil:

\begin{itemize}
\tightlist
\item
  Misalkan kegiatan pertama yang kita ikuti adalah kegiatan ke-

  .
\item
  Kegiatan selanjutnya yang diikuti haruslah memiliki waktu awal

  .
\item
  Lebih jauh lagi, ternyata kita mendapat persoalan yang serupa, hanya
  saja ukurannya lebih kecil.
\item
  Dengan kata lain, kita memperoleh sub-persoalan.
\end{itemize}

Untuk setiap sub-persoalan, kita harus memilih sebuah Greedy Choice.
Pada soal ini, setidaknya terdapat 3 Greedy choice:

\begin{itemize}
\item
  Memilih aktivitas dengan waktu mulai paling awal.

  pilihan ini tidak tepat, karena bisa jadi ada aktivitas yang mulai
  lebih awal, tetapi memiliki durasi yang sangat panjang sehingga
  menyita waktu.
\item
  Memilih aktivitas dengan durasi paling singkat.

  pilihan ini juga tidak tepat. Bisa jadi aktivitas dengan durasi paling
  singkat ini memotong dua aktivitas lain yang sebenarnya dapat kita
  ikuti.
\item
  Memilih aktivitas dengan waktu akhir paling awal.

  Dengan memilih aktivitas yang selesai lebih awal, kita mempunyai sisa
  waktu lebih banyak untuk aktivitas lainnya.
\end{itemize}

\subsection{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\tightlist
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/54/lessons/22/}{Materi
  Greedy TLX Training Gate}
\end{itemize}

\subsection{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan-3}

\subsection{Pengurutan dan Pencarian}\label{pengurutan-dan-pencarian}

Pengurutan melingkupi teknik-teknik mengurutkan data, seperti:

\begin{itemize}
\item ~
  \paragraph{Bubble sort}\label{bubble-sort}

  Bubble sort adalah teknik pengurutan data dengan membandingkan suatu
  elemen dengan elemen yang bersebelahan, dan menukarnya jika urutannya
  terbalik. Proses ini diulang hingga data terurut.
\item ~
  \paragraph{Insertion Sort}\label{insertion-sort}

  Insertion sort bekerja dengan menyisipkan elemen pada data satu
  persatu sehingga hasil penyisipan selalu terurut.
\item ~
  \paragraph{Counting Sort}\label{counting-sort}

  Counting sort dilakukan dengan menghitung berapa kemunculan elemen
  dengan nilai 1, 2, 3, \ldots{}, hingga K. Kemudian, angka tersebut
  ditampilkan lagi secara terurut.
\item ~
  \paragraph{Merge Sort dan Quick Sort}\label{merge-sort-dan-quick-sort}

  Ini adalah teknik pengurutan lanjutan. Akan dijelaskan pada bab Divide
  and Conquer
\end{itemize}

Sesuai namanya, pencarian adalah proses mencari suatu elemen pada data.
Secara umum terdapat 2 teknik pencarian:

\begin{itemize}
\item ~
  \paragraph{Linear Search}\label{linear-search}

  Linear search adalah proses mencari elemen pada suatu data dengan
  membandingkan elemen yang ingin dicari pada setiap elemen pada data
  satu persatu.
\item ~
  \paragraph{Binary Search}\label{binary-search}

  Jika data yang ada terurut, maka kita dapat mencari lebih efisien.
  Pada binary search, kita membandingkan elemen yang ingin dicari pada
  elemen tengah data. Jika elemen tersebut lebih kecil dari elemen
  tengah pada data, Anda cukup mencari lagi di separuh pertama data
  tersebut. Jika tidak, kita cari di separuh terakhir. Proses ini
  dilakukan hingga elemen ditemukan atau data sudah tidak bisa dibagi
  lagi.
\end{itemize}

Contoh soal 1:

\begin{quote}
Anda diberikan sebuah array A yang terdiri dari N buah bilangan.
Keluarkan array tersebut dalam kondisi terurut menaik.

\begin{verbatim}
Contoh  : A = [10, 7, 3, 6]
Jawaban : [3, 6, 7, 10]
\end{verbatim}
\end{quote}

Contoh soal 2:

\begin{quote}
Anda diberikan sebuah array A yang terdiri dari N buah bilangan, dan
sebuah bilangan D. Tentukan indeks dari bilangan D pada array tersebut.
Jika D tidak ditemukan, keluarkan -1

\begin{verbatim}
Contoh 1  : A = [10, 7, 3, 6] , D = 7
Jawaban 1 : 2

Contoh 1  : A = [10, 7, 3, 6] , D = 9
Jawaban 1 : -1
\end{verbatim}
\end{quote}

Soal pertama adalah soal pengurutan klasik. Soal ini bisa diselesaikan
dengan salah satu teknik pengurutan, misalnya bubble sort. Namun perlu
diperhatikan, jika ukuran array cukup besar, maka harus menggunakan
teknik pengurutan yang lebih cepat.

Soal kedua adalah soal pencarian. Solusinya adalah dengan melakukan
sequential search sebagai berikut:

\begin{itemize}
\tightlist
\item
  Periksa satu per satu dari sepatu pertama, kedua, ketiga, dan
  seterusnya.
\item
  Jika ditemukan, langsung laporkan.
\item
  Jika sampai akhir belum juga ditemukan, artinya angka yang dicari
  tidak ada pada daftar.
\end{itemize}

\subsection{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/1/chapters/16/lessons/13/}{Materi
  Pengurutan dasar: Bubble Sort, Insertion Sort, dan Counting Sort}

  catatan: Sorting lanjutan seperti Quick Sort dan Merge Sort akan
  dipelajari di bab Divide and Conquer
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/1/chapters/15/lessons/12/}{Materi
  Pencarian TLX Training Gate}
\end{itemize}

\subsection{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan-4}

\subsection{Struktur Data Linear}\label{struktur-data-linear}

Struktur data linear adalah struktur data yang dibangun pada array.
Dalam OSN, terdapat 2 struktur data linear yang masuk dalam kurikulum:

\begin{itemize}
\item ~
  \paragraph{Queue}\label{queue}

  Queue adalah struktur data dimana kita dapat memasukkan elemen, dan
  mengeluarkan elemen sesuai dengan urutan masukknya. Pada Queue, elemen
  yang pertama dikeluarkan adalah elemen yang pertama kali masuk, mirip
  seperti antrian dalam dunia nyata.
\item ~
  \paragraph{Stack}\label{stack}

  Pada Stack, kita dapat memasukkan elemen dan mengeluarkan elemen yang
  terakhir kali dimasukkan.
\end{itemize}

Contoh soal:

\begin{quote}
Anda diberikan sebuah string yang terdiri dari kurung ``(``, ``)'', dan
kurung siku ``{[}'', ``{]}''. Tentukan apakah string tersebut merupakan
barisan kurung yang valid. Barisan kurung yang valid adalah setiap
kurung buka memiliki pasangan kurung tutup dengan urutan yang benar.

\begin{verbatim}
Contoh 1  : "([])"
Jawaban 1 : VALID

Contoh 2  : "([)]"
Jawaban 2 : TIDAK VALID

Contoh 3  : "(())[][]"
Jawaban 3 : VALID

Contoh 4  : "]["
Jawaban 4 : TIDAK VALID
\end{verbatim}
\end{quote}

Kita dapat memanfaatkan struktur data Stack. Siapkanlah sebuah stack
kosong. Lakukan perulangan terhadap string S. Setiap kali kita menemukan
kurung buka ``(`` ataupun ``{]}'', masukkan ke dalam stack. Setiap kali
kita menemukan kurung tutup, lihat elemen teratas pada stack dan
pastikan pasangan kurungnya tepat.

\subsection{Tautan Pendalaman Materi:}\label{tautan-pendalaman-materi}

\begin{itemize}
\tightlist
\item
  \href{https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/56/lessons/25/}{Materi
  Struktur Data Dasar TLX Training Gate}
\end{itemize}

\subsection{}\label{rekomandasi-soal-soal-latihan}

\subsubsection{Soal Latihan}\label{soal-latihan-5}

\end{document}
