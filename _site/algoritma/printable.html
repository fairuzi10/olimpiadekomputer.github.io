<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="robots" content="noindex">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/print.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- math functions -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body class="layout">

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="container content">
        

	

	

	
		
		<h2> Aritmetika dan aturan berhitung </h2>
		<p>Aritmetika dan aturan berhitung melingkupi:</p>

<h3 id="aritmetika-modular">Aritmetika modular</h3>
<p>Operasi \(a \bmod m\), atau biasa disebut “\(a\) modulo \(m\)” memberikan sisa hasil bagi \(a\) oleh \(m\).
Fungsi mod ini biasa muncul di OSN untuk menghindari angka yang terlalu besar.
<!--more--></p>

<p>Sifat modulo:</p>
<ul>
  <li>\((A \times B) \mod C = ((A \mod C) \times (B \mod C)) \mod C\)</li>
  <li>\((A + B) \mod C = ((A \mod C) + (B \mod C)) \mod C\)</li>
  <li>\((A - B) \mod C = ((A \mod C) - (B \mod C) + C) \mod C\)</li>
  <li>\((A / B) \mod C = (A \times (B^{C-2} \mod C)) \mod C\) , hanya berlaku jika C adalah prima</li>
</ul>

<!--more-->

<h3 id="bilangan-prima">Bilangan prima</h3>

<p>Bilangan prima adalah bilangan bulat positif yang hanya habis dibagi oleh 1 dan dirinya sendiri. Anda diharapkan dapat melakukan pengecekan prima dengan cara perulangan dari 2 sampai \(\sqrt{N}\), maupun dengan teknik sieve of erathothenes.</p>

<h3 id="kpk-dan-fpb">KPK dan FPB</h3>
<p>Anda diharapkan dapat mencari KPK dan FPB dengan memanfaatkan faktorisasi prima.
<!--more--></p>
<ul>
  <li>fpb(A,0) = A</li>
  <li>fpb(A,B) = fpb(B, A mod B)</li>
  <li>kpk(A,B) = A x B / fpb(A, B)</li>
</ul>

<p>Dalam C++, fpb dapat dihitung menggunakan fungsi berikut:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">__gcd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span></code></pre></figure>

<!--more-->

<h3 id="pigeonhole-principle">Pigeonhole Principle</h3>
<p>Konsep PHP menyatakan bahwa “Jika ada \(N\) burung dan \(M\) sangkar, dimana \(N &gt; M\) , maka ada sangkar yang berisi setidaknya 2 ekor burung”.
Secara matematis, jika ada \(N\) burung dan \(M\) sangkar, maka ada sangkar yang berisi setidaknya \(\big\lceil \frac{N}{M} \big\rceil\) ekor burung.</p>

<h3 id="aturan-perkalian-dan-penjumlahan">Aturan perkalian dan penjumlahan</h3>

<h3 id="permutasi-dan-kombinasi">Permutasi dan kombinasi</h3>
<p>Permutasi dari \(N\) adalah seluruh cara pengurutan \(N\) objek tersebut. Banyaknya permutasi dari \(N\) dinyatakan dalam faktorial, atau \(N!\).
<!--more--> Rumus faktorial, dinotasikan \(N!\) adalah hasil kali dari 1 sampai \(N\), sehingga \(N! = 1 \times 2 \times 3 \times \dots \times N\) <!--more-->
Kombinasi adalah banyaknya cara mengambil \(K\) buah objek dari \(N\) pilihan yang ada, tanpa memerdulikan urutan. Notasi kombinasi ini dinyatakan dalam \(C^{N}_{K} = \frac{N!}{K!(N-K)!}\).
<!--more--></p>

<p>Untuk menghitung kombinasi dengan nilai N besar, Anda tidak dapat melakukan perhitungan N! terlebih dahulu, kemudian menghitung pembaginya. Manfaatkan sifat modulo pembagian!
<!--more--></p>

<h3 id="probabilitas">Probabilitas</h3>
<p>Menghitung kemungkinan terjadinya suatu persistiwa. Sebagai contoh, jika terdapat \(N\) bola merah dan \(M\) bola biru, dan Anda mengambil tepat 2 bola secara acak, berapa kemungkinan bahwa kedua bola berwarna biru? Banyaknya cara mengambil 2 bola biru adalah \( C^N_2 \) dan banyaknya cara mengambil 2 bola sembarang warna adalah \(C_2^{N+M} \), maka probabilitasnya adalah \( \frac{C^{N}_{2}}{C^{N+M}_2}\) .</p>

<h3 id="prinsip-inklusi-dan-eksklusi">Prinsip Inklusi dan Eksklusi</h3>

<h3 id="segitiga-pascal">Segitiga Pascal</h3>
<p>Segitiga Pascal merupakan susunan dari Koefisien Binomial dalam bentuk segitiga.
Nilai dari baris ke-n suku ke-r adalah \(A_{ij} = C^{n}_{r}\).</p>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/lessons/18/">Materi Kombinatorik TLX Training Gate</a></li>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/lessons/17/">Materi Matematika Diskret TLX Training Gate</a></li>
</ul>

<h3 id="contoh-soal">Contoh soal:</h3>

<blockquote>
  <p>Anda diberikan sebuah string S. Ada berapa kata berbeda yang dapat disusun dari huruf-huruf penyusun kata S?</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>Contoh 1  : S = 'aba'. 
Jawaban 1 : 3 ('aab', 'aba', 'baa')

Contoh 2  : S = 'MEGAGIGA'
Jawaban 2 : 3360
</code></pre>
  </div>
  <!--more-->
</blockquote>

<p>Solusi soal tersebut adalah:</p>
<ul>
  <li>Terdapat N huruf, sehingga banyak kata yang dapat kita susun adalah \(N!\).</li>
  <li>Apabila terdapat K huruf dengan setiap hurufnya memiliki \(R_{i}\) huruf yang sama, maka dengan prinsip Redundansi banyak kata berbeda yang dapat disusun adalah \(\frac{N!}{(R_{1}! \times R_{2}! \times R_{3}! \times … \times R_{K}!)}\).</li>
</ul>

<p><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/problems/225/">TLX: Faktorisasi Prima</a></p>
<blockquote>
  <p>Anda diberikan sebuah bilangan bulat \(N (1 \le N \le 1.000.000)\) . Tentukan bilangan-bilangan prima a1, a2, …, ak dan pangkat-pangkatnya, b1, b2, …, bk, sehingga \(N = a1^{b1} \times a2^{b2} \times \dots \times ak^{bk}\).</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Cari seluruh faktor prima dari masukan. Kemudian cetak sesuai keinginan.</p>

</details>

<p><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/problems/226/">TLX: Penjumlahan Pecahan</a></p>
<blockquote>
  <p>Anda diberikan dua buah pecahan dalam bentuk A/B dan C/D. Hitunglah A/B + C/D, lalu cetak hasilnya dalam bentuk yang paling sederhana. Bentuk paling sederhana dari suatu pecahan adalah ketika FPB dari pembilang dan penyebutnya adalah 1.</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Jawaban adalah dalam bentuk E/F di mana \(E = \frac{(A \times D + B \times C)}{gcd(C,D)}\) dan \(F = \frac{C \times D}{gcd(C,D)}\)</p>

</details>

<p><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/problems/227/">TLX: Prima ke-K</a></p>
<blockquote>
  <p>Carilah bilangan prima ke-K. Buatlah program yang efisien agar Anda dapat menjawab pertanyaan tersebut berkali-kali!</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Anda dapat melakukan perulangan dari 1,2,3, dan seterusnya. Pada setiap bilangan, cek apakah bilangan tersebut adalah bilangan prima. Namun, solusi tersebut tidak efisien, mengingat Anda harus mencari bilangan prima ke-K pada banyak nilai K berbeda! Gunakan Sieve of Erathosthenes untuk menghasilkan 77.777 bilangan prima pertama. Kemudian cetak sesuai masukan.</p>

</details>

<p><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/51/problems/228/">TLX: Pasar Rakyat</a></p>
<blockquote>
  <p>Ada N Pedagang yang datang mengunjungi suatu pasar secara periodik dalam beberapa hari sekali. Pedagang ke-i datang setiap \(D_i\) hari sekali. Setiap berapa hari sekali semua pedagang akan datang secara bersamaan?</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Hitung KPK dari seluruh nilai \(D_i\)</p>

</details>

<p><a href="https://training.ia-toki.org/problemsets/70/problems/352/">OSN 2006: Faktorial</a></p>
<blockquote>
  <p>Carilah berapa angka 0 berurutan yang mengakhiri \(N!\). Misalnya 10! = 3.628.800, maka jumlah 0 berurutan adalah 2. Sementara 8! = 40.320, maka jumlah 0 berurutan adalah 1 (nol di tengah tidak dihitung).</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Menghitung nilai asli dari N! tidak memungkinkan karena terlalu besar. Namun, kita cukup mencari banyaknya faktor 2 dan 5 dari N!, karena 2*5 = 10 (menghasilkan digit 0)</p>

</details>

<p><a href="http://codeforces.com/problemset/problem/478/B">Codeforces: Random Teams</a></p>
<blockquote>
  <p>bla</p>
</blockquote>

<details>
	<summary>[Solusi]</summary>
	<p>Untuk pasangan teman minimum, distribusikan tim dengan semerata mungkin. Untuk pasangan teman maksimum, distribusikan tim dengan anggota 1 untuk m -1 tim, dan sisanya di tim terakhir. Banyaknya pasangan teman dari suatu tim dengan anggota X orang adalah kombinasi 2 dari X.</p>

</details>


		<h3> Soal Latihan </h3>

		
		<h4> TLX: Faktorisasi Prima </h4>
		<blockquote> <p>Anda diberikan sebuah bilangan bulat \(N (1 \le N \le 1.000.000)\) . Tentukan bilangan-bilangan prima a1, a2, …, ak dan pangkat-pangkatnya, b1, b2, …, bk, sehingga \(N = a1^{b1} \times a2^{b2} \times \dots \times ak^{bk}\).</p>
 </blockquote>

		
		<h4> TLX: Penjumlahan Pecahan </h4>
		<blockquote> <p>Anda diberikan dua buah pecahan dalam bentuk A/B dan C/D. Hitunglah A/B + C/D, lalu cetak hasilnya dalam bentuk yang paling sederhana. Bentuk paling sederhana dari suatu pecahan adalah ketika FPB dari pembilang dan penyebutnya adalah 1.</p>
 </blockquote>

		
		<h4> TLX: Prima ke-K </h4>
		<blockquote> <p>Carilah bilangan prima ke-K. Buatlah program yang efisien agar Anda dapat menjawab pertanyaan tersebut berkali-kali!</p>
 </blockquote>

		
		<h4> TLX: Pasar Rakyat </h4>
		<blockquote> <p>Ada N Pedagang yang datang mengunjungi suatu pasar secara periodik dalam beberapa hari sekali. Pedagang ke-i datang setiap \(D_i\) hari sekali. Setiap berapa hari sekali semua pedagang akan datang secara bersamaan?</p>
 </blockquote>

		
		<h4> OSN 2006: Faktorial </h4>
		<blockquote> <p>Carilah berapa angka 0 berurutan yang mengakhiri \(N!\). Misalnya 10! = 3.628.800, maka jumlah 0 berurutan adalah 2. Sementara 8! = 40.320, maka jumlah 0 berurutan adalah 1 (nol di tengah tidak dihitung).</p>
 </blockquote>

		
		<h4> Codeforces: Random Teams </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	

	
		
		<h2> Pengurutan dan Pencarian </h2>
		<p>Dalam OSN, anda diharapkan menguasai teknik mengurutkan data berikut:</p>

<h3 id="bubble-sort">Bubble sort</h3>
<p>Bubble sort adalah teknik pengurutan data dengan membandingkan suatu elemen dengan elemen yang bersebelahan, dan menukarnya jika urutannya terbalik. Proses ini diulang hingga data terurut.</p>

<h3 id="insertion-sort">Insertion Sort</h3>
<p>Insertion sort bekerja dengan menyisipkan elemen pada data satu persatu sehingga hasil penyisipan selalu terurut.</p>

<h3 id="counting-sort">Counting Sort</h3>
<p>Counting sort dilakukan dengan menghitung berapa kemunculan elemen dengan nilai 1, 2, 3, …, hingga K. Kemudian, angka tersebut ditampilkan lagi secara terurut.
<!--more--></p>
<ul>
  <li>Perhatikan batasan-batasan dalam soal. Jika elemen-elemen pada soal memiliki range yang terbatas, misalnya umur, atau berat badan, biasanya dapat diurutkan dengan counting sort.
<!--more--></li>
</ul>

<h3 id="merge-sort-dan-quick-sort">Merge Sort dan Quick Sort</h3>
<p>Ini adalah teknik pengurutan lanjutan. Akan dijelaskan pada bab Divide and Conquer
<!--more--></p>
<ul>
  <li>Anda harus penguasai paling tidak satu teknik pengurutan dengan kompleksitas O(N log N) ini, karena umumnya teknik pengurutan kuadratik terlalu lambat untuk ukuran data pada soal OSN.</li>
  <li>Merge sort juga dapat digunakan untuk menyelesaikan inversi:
    <blockquote>
      <p>Diberikan sebuah array dengan N buah bilangan. Anda ingin mengurutkan array tersebut dengan cara menukar 2 elemen bersebelahan. Berapa pertukaran (swap) minimal yang mungkin untuk mengurutkan array tersebut?</p>
    </blockquote>
  </li>
</ul>

<p>Jawaban dari soal tersebut adalah total swap yang terjadi saat melakukan merge sort.</p>

<!--more-->
<h3 id="linear-search">Linear Search</h3>
<p>Linear search adalah proses mencari elemen pada suatu data dengan membandingkan elemen yang ingin dicari pada setiap elemen pada data satu persatu.</p>

<h3 id="binary-search">Binary Search</h3>
<p>Jika data yang ada terurut, maka kita dapat mencari lebih efisien. Pada binary search, kita membandingkan elemen yang ingin dicari pada elemen tengah data. Jika elemen tersebut lebih kecil dari elemen tengah pada data, Anda cukup mencari lagi di separuh pertama data tersebut. Jika tidak, kita cari di separuh terakhir. Proses ini dilakukan hingga elemen ditemukan atau data sudah tidak bisa dibagi lagi.</p>

<!--more-->
<ul>
  <li>Binary-search tidak hanya digunakan untuk mencari data. Kadang kala Anda harus melakukan Binary-Search pada jawaban. Salah satu indikasinya adalah jika jawaban yang Anda cari memiliki properti dimana jika N adalah jawaban valid, maka N+1 dijamin selalu valid. Contohnya:</li>
</ul>

<p>CONTOH SOAL BINARY SEARCH DI JAWABAN.</p>

<h4 id="tips-dan-trik-umum">Tips dan Trik Umum</h4>

<ul>
  <li>Biasanya dalam OSN tidak terdapat soal yang murni hanya pengurutan saja. Namun Anda perlu melakukan pengurutan data dahulu sebelum soal tersebut bisa diselesaikan.</li>
  <li>Jika Anda hanya perlu mengurutkan data saja, Anda akan menghemat waktu jika menggunakan C++, karena C++ memiliki STL untuk melakukan pengurutan:</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="cm">/* 4 adalah ukuran array */</span></code></pre></figure>

<ul>
  <li>Jika Anda memiliki data yang terurut, Anda bisa menggunakan STL pada C++ untuk melakukan binary search.</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span> <span class="cm">/* terurut */</span>
<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">idx</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="cm">/* nilainya 3 (index 5 pada array a) */</span></code></pre></figure>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li>
    <p><a href="https://training.ia-toki.org/training/curriculums/1/courses/1/chapters/16/lessons/13/">Materi Pengurutan dasar: Bubble Sort, Insertion Sort, dan Counting Sort</a></p>

    <p>catatan: Sorting lanjutan seperti Quick Sort dan Merge Sort akan dipelajari di bab Divide and Conquer</p>
  </li>
  <li>
    <p><a href="https://training.ia-toki.org/training/curriculums/1/courses/1/chapters/15/lessons/12/">Materi Pencarian TLX Training Gate</a></p>
  </li>
</ul>

<!--more-->

<h3 id="contoh-soal">Contoh soal</h3>

<blockquote>
  <p>Anda diberikan sebuah array A yang terdiri dari N buah bilangan. Keluarkan array tersebut dalam kondisi terurut menaik.</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>Contoh  : A = [10, 7, 3, 6]
Jawaban : [3, 6, 7, 10]
</code></pre>
  </div>
</blockquote>

<!--more-->

<p>Soal ini adalah soal pengurutan klasik. Soal ini bisa diselesaikan dengan salah satu teknik pengurutan, misalnya bubble sort.
Namun perlu diperhatikan, jika ukuran array cukup besar, maka harus menggunakan teknik pengurutan yang lebih cepat.</p>

<ul>
  <li><a href="https://training.ia-toki.org/problemsets/66/problems/332/">OSN 2009: Paduan Suara</a>
    <blockquote>
      <p>bla</p>
    </blockquote>
    <details>
  <summary>[Solusi]</summary>
  </details>
  </li>
  <li><a href="https://training.ia-toki.org/problemsets/2/problems/4/">OSN 2015: Pertahanan Yogya</a>
    <blockquote>
      <p>bla</p>
    </blockquote>
    <details>
  <summary>[Solusi]</summary>
  </details>
  </li>
</ul>


		<h3> Soal Latihan </h3>

		
		<h4> OSN 2009: Paduan Suara </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2015: Pertahanan Yogya </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	

	
		
		<h2> Brute Force </h2>
		<p>Brute-force merupakan suatu strategi penyelesaian masalah dengan mencoba semua kemungkinan. Brute-force menjamin solusi selalu benar, namun biasanya lambat karena menjelajahi semua kemungkinan solusi. Pada OSN, Brute-force berguna untuk menguji kebenaran solusi utama kita. Selain itu, biasanya tiap soal selalu memiliki sub-task yang bisa diselesaikan dengan teknik Brute-force.</p>

<p>Contoh soal:</p>

<blockquote>
  <p>Anda diberikan sebuah array A yang terdiri dari N buah bilangan, dan juga bilangan K. Apakah terdapat subset dari bilangan-bilangan tersebut sehingga jumlahan dari elemen subset tersebut sama dengan K? item Bila iya, maka keluarkan “YA”. Selain itu keluarkan “TIDAK”</p>
  <div class="highlighter-rouge"><pre class="highlight"><code>Contoh  1 : A = [1, 3, 6, 10], K = 14
Jawaban 1 : "YA" (K = 1 + 3 + 10)

Contoh  2 : A = [1, 3, 6, 10], K = 15
Jawaban 2 : "TIDAK"
</code></pre>
  </div>
</blockquote>

<!--more-->

<p>Solusi soal di atas adalah:</p>
<ul>
  <li>Untuk setiap elemen, kita memiliki 2 pilihan yaitu memilih elemen tersebut atau tidak memilihnya.</li>
  <li>Kita akan menelusuri semua kemungkinan pilihan.</li>
  <li>Jika jumlahan dari elemen-elemen yang dipilih sama dengan \(K \), maka terdapat solusi.</li>
  <li>Hal ini dapat dengan mudah diimplementasikan secara rekursif.</li>
</ul>

<p>Mari kita analisa solusi tersebut. Terdapat \(2^N \) kemungkinan pilih-tidak pilih, sehingga kompleksitas solusi adalah \(O(2^N) \). Nilai \(2^N \) tumbuh dengan sangat cepat, sehingga solusi ini hanya dapat menyelesaikan soal tersebut jika \(N \) kecil.</p>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/52/lessons/19/">Materi Brute-Force TLX Training Gate</a></li>
</ul>

<h4 id="rekomandasi-soal-soal-latihan">
</h4>

		<h3> Soal Latihan </h3>

		
		<h4> OSN 2007: Permutasi Ekspresi </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2012: Kontes Menari </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	

	
		
		<h2> Greedy </h2>
		<p>merupakan sebuah teknik dalam strategi penyelesaian masalah. Suatu persoalan dapat diselesaikan dengan teknik Greedy jika persoalan tersebut memiliki memiliki properti berikut:</p>
<ul>
  <li>Solusi optimal dari persoalan dapat ditentukan dari solusi optimal sub-persoalan tersebut.</li>
  <li>Pada setiap sub-persoalan, ada suatu langkah yang bisa dilakukan yang mana langkah tersebut menghasilkan solusi optimal pada sub-persoalan tersebut. Langkah ini disebut juga Greedy Choice.</li>
</ul>

<p>Contoh soal:</p>

<blockquote>
  <p>Diberikan \(N\)  buah aktivitas.</p>
  <ul>
    <li>Aktivitas ke-\( i\)  dinyatakan dalam \(&lt;a_i.start, a_i.end&gt;\) .</li>
    <li>Artinya, aktivitas ini dimulai pada waktu \(a_i.start\)  dan berakhir pada waktu \(a_i.end\) .</li>
    <li>Pada setiap satuan waktu, Anda dapat mengikuti paling banyak satu aktivitas.</li>
    <li>Anda ingin mengatur jadwal sedemikian sehingga Anda bisa ikut aktivitas sebanyak mungkin.
      <div class="highlighter-rouge"><pre class="highlight"><code>Contoh  : aktifitas = [&lt;1, 3&gt; , &lt;2, 6&gt;, &lt;5, 7&gt;,  &lt;8, 9&gt;]
Jawaban : [&lt;1, 3&gt;, &lt;5, 7&gt;, &lt;8, 9&gt;]
</code></pre>
      </div>
    </li>
  </ul>
</blockquote>

<!--more-->
<p>Untuk menyelesaikan soal tersebut, kita lihat apakah soal tersebut dapat dijadikan subsoal yang lebih kecil:</p>
<ul>
  <li>Misalkan kegiatan pertama yang kita ikuti adalah kegiatan ke-\( x\) .</li>
  <li>Kegiatan selanjutnya yang diikuti haruslah memiliki waktu awal \(\geq a_x.end\) .</li>
  <li>Lebih jauh lagi, ternyata kita mendapat persoalan yang serupa, hanya saja ukurannya lebih kecil.</li>
  <li>Dengan kata lain, kita memperoleh sub-persoalan.</li>
</ul>

<p>Untuk setiap sub-persoalan, kita harus memilih sebuah Greedy Choice. Pada soal ini, setidaknya terdapat 3 Greedy choice:</p>
<ul>
  <li>
    <p>Memilih aktivitas dengan waktu mulai paling awal.</p>

    <p>pilihan ini tidak tepat, karena bisa jadi ada aktivitas yang mulai lebih awal, tetapi memiliki durasi yang sangat panjang sehingga menyita waktu.</p>
  </li>
  <li>
    <p>Memilih aktivitas dengan durasi paling singkat.</p>

    <p>pilihan ini juga tidak tepat. Bisa jadi aktivitas dengan durasi paling singkat ini memotong dua aktivitas lain yang sebenarnya dapat kita ikuti.</p>
  </li>
  <li>
    <p>Memilih aktivitas dengan waktu akhir paling awal.</p>

    <p>Dengan memilih aktivitas yang selesai lebih awal, kita mempunyai sisa waktu lebih banyak untuk aktivitas lainnya.</p>
  </li>
</ul>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/54/lessons/22/">Materi Greedy TLX Training Gate</a></li>
</ul>

<h4 id="rekomandasi-soal-soal-latihan">
</h4>

		<h3> Soal Latihan </h3>

		
		<h4> TLX: Rak Buku </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	

	
		
		<h2> Dynamic Programming </h2>
		<p>Dynamic Programming (DP) merupakan sebuah teknik dalam strategi penyelesaian masalah. Seperti Greedy, suatu persoalan dapat diselesaikan dengan teknik DP jika solusi optimal dari persoalan dapat ditentukan dari solusi optimal sub-persoalan tersebut. Perbedaannya, pada DP, sub-persoalan tersebut muncul berkali-kali di mana kita menyimpan solusi optimal dari sub-persoalan tersebut dalam tabel. Untuk menguasai DP, dibutuhkan banyak latihan soal. DP hampir selalu muncul dalam OSN (Silahkan lihat contoh-contoh soal) dan sangat direkomendasikan untuk Anda menguasai topik ini.</p>

<p>Contoh soal:</p>

<blockquote>
  <ul>
    <li>Diberikan \(M \)  jenis koin, masing-masing jenis bernilai \(a_1, a_2, …, a_M \)  rupiah.</li>
    <li>Asumsikan terdapat tak hingga koin untuk setiap nominal koin yang ada.</li>
    <li>Tentukan berapa banyaknya minimum koin untuk membayar sebesar \(N \)  rupiah!</li>
  </ul>

  <div class="highlighter-rouge"><pre class="highlight"><code>Contoh 1  :  M = [1, 6, 10], N = 12
Jawaban 1 :  2 (6 + 6)
</code></pre>
  </div>
  <!--more-->
</blockquote>

<p>Soal tersebut adalah soal DP klasik “Coin Change”. Mari perhatikan properti berikut:</p>
<ul>
  <li>Untuk membayar \(N \)  rupiah, kita dapat memilih salah satu koin terlebih dahulu.</li>
  <li>Jika nilai koin itu adalah \(a_k \) , maka sisa uang uang perlu kita bayar adalah \(N-a_k \) .</li>
  <li>Perhatikan bahwa penukaran \(N - a_k \)  merupakan suatu sub-persoalan yang serupa dengan persoalan awalnya. Artinya, cara yang sama untuk menyelesaikan sub-persoalan dapat digunakan.</li>
</ul>

<p>Bagaimana menyelesaikan soal tersebut secara DP?</p>
<ul>
  <li>Definisikan sebuah fungsi \(f(x) \)  sebagai banyaknya koin minimum yang dibutuhkan untuk membayar \(x \)  rupiah.</li>
  <li>Kita dapat mencoba-coba koin yang ingin kita gunakan.</li>
  <li>Jika suatu koin \(a_k \)  digunakan, maka kita membutuhkan \(f(x-a_k) \)  koin ditambah satu koin \(a_k \) .</li>
  <li>Atau dapat ditulis \(f(x) = f(x-a_k) + 1 \)</li>
  <li>Pencarian nilai \(f(x-a_k) \)  dilakukan secara rekursif, kita kembali mencoba-coba koin yang ingin digunakan.</li>
  <li>Fungsi \(f(x) \)  ini akan dikunjungi berkali-kali! Sehingga nilai \(f(x) \)  perlu kita simpan dalam tabel.</li>
</ul>

<p>Ini adalah salah satu contoh permasalahan DP klasik. Untuk contoh-contoh klasik lainnnya, bisa dilihat di Materi Contoh DP Klasik TLX Training Gate berikut.</p>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/55/lessons/23/">Materi Perkenalan DP TLX Training Gate</a></li>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/55/lessons/24/">Materi Studi Kasus DP TLX Training Gate</a></li>
</ul>

<h4 id="rekomandasi-soal-soal-latihan">
</h4>

		<h3> Soal Latihan </h3>

		
		<h4> TLX:  Perkalian Matriks Bebek </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> TLX:  Palindrom </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> TLX:  Knapsack </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> TLX:  Penukaran Emas </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2008:  Memasang Lantai </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2009:  Sepatu </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2010:  Waterfall </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2013:  Cuti Liburan </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2014:  Pelontar Bebek </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		
		<h4> OSN 2015:  Menyiram Sawah </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	

	
		
		<h2> Struktur Data Linear </h2>
		<p>Struktur data linear adalah struktur data yang dibangun pada array. Dalam OSN, terdapat 2 struktur data linear yang masuk dalam kurikulum:</p>
<h3 id="queue">Queue</h3>
<p>Queue adalah struktur data dimana kita dapat memasukkan elemen, dan mengeluarkan elemen sesuai dengan urutan masukknya. Pada Queue, elemen yang pertama dikeluarkan adalah elemen yang pertama kali masuk, mirip seperti antrian dalam dunia nyata.</p>

<h3 id="stack">Stack</h3>
<p>Pada Stack, kita dapat memasukkan elemen dan mengeluarkan elemen yang terakhir kali dimasukkan.</p>

<p>Contoh soal:</p>

<blockquote>
  <p>Anda diberikan sebuah string yang terdiri dari kurung “(“, “)”, dan kurung siku “[”, “]”.
Tentukan apakah string tersebut merupakan barisan kurung yang valid. Barisan kurung yang valid adalah setiap kurung buka memiliki pasangan kurung tutup dengan urutan yang benar.</p>

  <div class="highlighter-rouge"><pre class="highlight"><code>Contoh 1  : "([])"
Jawaban 1 : VALID

Contoh 2  : "([)]"
Jawaban 2 : TIDAK VALID

Contoh 3  : "(())[][]"
Jawaban 3 : VALID

Contoh 4  : "]["
Jawaban 4 : TIDAK VALID
</code></pre>
  </div>
  <!--more-->
</blockquote>

<p>Kita dapat memanfaatkan struktur data Stack. Siapkanlah sebuah stack kosong. Lakukan perulangan terhadap string S. Setiap kali kita menemukan kurung buka “(“ ataupun “]”, masukkan ke dalam stack. Setiap kali kita menemukan kurung tutup, lihat elemen teratas pada stack dan pastikan pasangan kurungnya tepat.</p>

<h4 id="tautan-pendalaman-materi">Tautan Pendalaman Materi:</h4>
<ul>
  <li><a href="https://training.ia-toki.org/training/curriculums/1/courses/11/chapters/56/lessons/25/">Materi Struktur Data Dasar TLX Training Gate</a></li>
</ul>

<h4 id="rekomandasi-soal-soal-latihan">
</h4>

		<h3> Soal Latihan </h3>

		
		<h4> OSN 2013: Lipat Kertas </h4>
		<blockquote> <p>bla</p>
 </blockquote>

		

	


<h2> Pembahasan Soal Latihan </h2>

	

	

	
		<h3> Aritmetika dan aturan berhitung </h3>
		
		
		<h4> TLX: Faktorisasi Prima </h4>
		<blockquote> <p>Cari seluruh faktor prima dari masukan. Kemudian cetak sesuai keinginan.</p>
 </blockquote>

		
		
		<h4> TLX: Penjumlahan Pecahan </h4>
		<blockquote> <p>Jawaban adalah dalam bentuk E/F di mana \(E = \frac{(A \times D + B \times C)}{gcd(C,D)}\) dan \(F = \frac{C \times D}{gcd(C,D)}\)</p>
 </blockquote>

		
		
		<h4> TLX: Prima ke-K </h4>
		<blockquote> <p>Anda dapat melakukan perulangan dari 1,2,3, dan seterusnya. Pada setiap bilangan, cek apakah bilangan tersebut adalah bilangan prima. Namun, solusi tersebut tidak efisien, mengingat Anda harus mencari bilangan prima ke-K pada banyak nilai K berbeda! Gunakan Sieve of Erathosthenes untuk menghasilkan 77.777 bilangan prima pertama. Kemudian cetak sesuai masukan.</p>
 </blockquote>

		
		
		<h4> TLX: Pasar Rakyat </h4>
		<blockquote> <p>Hitung KPK dari seluruh nilai \(D_i\)</p>
 </blockquote>

		
		
		<h4> OSN 2006: Faktorial </h4>
		<blockquote> <p>Menghitung nilai asli dari N! tidak memungkinkan karena terlalu besar. Namun, kita cukup mencari banyaknya faktor 2 dan 5 dari N!, karena 2*5 = 10 (menghasilkan digit 0)</p>
 </blockquote>

		
		
		<h4> Codeforces: Random Teams </h4>
		<blockquote> <p>Untuk pasangan teman minimum, distribusikan tim dengan semerata mungkin. Untuk pasangan teman maksimum, distribusikan tim dengan anggota 1 untuk m -1 tim, dan sisanya di tim terakhir. Banyaknya pasangan teman dari suatu tim dengan anggota X orang adalah kombinasi 2 dari X.</p>
 </blockquote>

		

	

	
		<h3> Pengurutan dan Pencarian </h3>
		
		
		<h4> OSN 2009: Paduan Suara </h4>
		<blockquote> <p>Lakukan pengurutan terhadap tinggi suara bebek-bebek. Jika terdapat N bebek dan kita ingin bagi dalam K kelompok, maka tiap kelompok minimal terdiri dari \(A = \lfloor\frac{N}{K} \rfloor\) anggota. Dari data yang sudah terurut, kita hanya perlu mencari elemen dengan index \(A, 2A, 3A, …, (K-1)A\)</p>
 </blockquote>

		
		
		<h4> OSN 2015: Pertahanan Yogya </h4>
		<blockquote> <p>Kita tentukan nilai \(Z_i\), yang artinya banyaknya kemampuan tambahan yang diperlukan sebelum kita bisa mengalahkan musuh ke-i. Nilai ini bisa dicari dengan menggunakan binary search. Setelah itu, urutkan musuh-musuh berdasarkan nilai \(Z_i\) mereka. Setelah itu, cukup lakukan simulasi untuk menentukan jawaban.</p>
 </blockquote>

		

	

	
		<h3> Brute Force </h3>
		
		
		<h4> OSN 2007: Permutasi Ekspresi </h4>
		<blockquote> <p>Lakukan simulasi, cari semua permutasi ekspresi yang valid. Karena masukan paling besar adalah 13 digit), maka ada 12 tempat di mana kita dapat menyelipkan operator ‘+’, ‘-‘, atau tanpa operator. Sehingga total semua cara yang valid hanyalah \(3^{12}\). Untuk mengecek hasil ekspresi yang unik, cukup simpan seluruh hasil di array dan lakukan pengurutan.</p>
 </blockquote>

		
		
		<h4> OSN 2012: Kontes Menari </h4>
		<blockquote> <p>Karena nilai N hanya 10, kita bisa coba lakukan brute-force di semua permutasi. Untuk setiap permutasi, simulasikan seluruh gerakan untuk mendapatkan total nilai keindahan, dan simpan pada array. Perhitungan kemungkinan rangkaian gerakan yang dapat memukau setiap juri dilakukan dengan melakukan pencarian pada array tersebut.</p>
 </blockquote>

		

	

	
		<h3> Greedy </h3>
		
		
		<h4> TLX: Rak Buku </h4>
		<blockquote> <p>Lakukan Greedy Choice dengan memilih bebek yang paling tinggi terlebih dahulu</p>
 </blockquote>

		

	

	
		<h3> Dynamic Programming </h3>
		
		
		<h4> TLX:  Perkalian Matriks Bebek </h4>
		<blockquote> <p>Ini adalah DP klasik “Matrix Chain Multiplication”. Silahkan gunakan soal ini untuk berlatih implementasi DP.</p>
 </blockquote>

		
		
		<h4> TLX:  Palindrom </h4>
		<blockquote> <p>Carilah “Longest Common Subsequence” dari string S dan reverse(S). “Longest Common Subsequence” sendiri adalah salah satu DP klasik.</p>
 </blockquote>

		
		
		<h4> TLX:  Knapsack </h4>
		<blockquote> <p>Ini adalah DP klasik “Knapsack”. Silahkan gunakan soal ini untuk berlatih implementasi DP.</p>
 </blockquote>

		
		
		<h4> TLX:  Penukaran Emas </h4>
		<blockquote> <p>Operasi penukaran emas dapat dituliskan dalam formula rekursif (f(x) = max(x, f(\lfloor \frac{x}{2} \rfloor) + f(\lfloor \frac{x}{3}  \rfloor) + f(\lfloor \frac{x}{4}  \rfloor) ) ). Anda bisa gunakan memoisasi pada formula rekursif tersebut.</p>
 </blockquote>

		
		
		<h4> OSN 2008:  Memasang Lantai </h4>
		<blockquote> <p>Cari formula rekursifnya, lalu lakukan memoisasi. Petunjuk, mirip dengan deret fibonacci.</p>
 </blockquote>

		
		
		<h4> OSN 2009:  Sepatu </h4>
		<blockquote> <p>Coba urutkan dulu ukuran kaki bebek dan ukuran sepatu yang ada. Cobalah definisikan fungsi f(x,y) yang berarti solusi optimal jika saat ini kita sudah memroses x bebek pertama dan y sepatu pertama. Catatan, soal ini juga dapat diselesaikan dengan teknik Greedy!</p>
 </blockquote>

		
		
		<h4> OSN 2010:  Waterfall </h4>
		<blockquote> <p>Coba definisikan fungsi f(x,y) yang artinya adalah berapa banyak tabrakan terjadi jika air muncul dari titik (x,y)</p>
 </blockquote>

		
		
		<h4> OSN 2013:  Cuti Liburan </h4>
		<blockquote> <p>Anggaplah f(i,j,k) berarti total daya maksimal jika kita memiliki pilihan baju dari nomor 1 sampai i, kapasitas koper sebanyak j, dan sudah ada k warna berbeda dalam koper. Permasalahannya adalah, saat kita mencoba suatu baju ke-i sebagai solusi, kita tidak tahu apakah warna baju ke-i sudah ada sebelumnya. Untuk menangani ini, kita dapat mengurutkan baju-baju tersebut sesuai warnanya, sehingga baju dengan warna yang sama akan selalu bersebelahan. Selanjutnya tambahkan 1 buah state pada DP tersebut yang menyatakan apakah baju dengan warna yang sama dengan baju ke-i sudah pernah dibawa atau belum. Bentuk akhir DP ini menjadi f(i,j,k,z) dengan z = 0 jika baju dengan warna yang sama dengan baju ke-i belum pernah dibawa, atau 1 jika sebaliknya.</p>
 </blockquote>

		
		
		<h4> OSN 2014:  Pelontar Bebek </h4>
		<blockquote> <p>Perhatikan sudut maksimal hanyalah 1800, sehingga meskipun ada 100000 pilihan roda gigi yang tersedia, namun hanya akan ada maksimal 1800 pilihan roda gigi dengan sudut berbeda. Untuk setiap sudut, pilihlah roda gigi dengan kecepatan maksimal. Setelah itu, cukup lakukan DP untuk pendapatkan nilai f(i,j) yang berarti nilai kecepatan maksimum yang didapat jika kita memiliki pilihan roda gigi dari nomor 1 sampai nomor i, dan sudut yang dicapai adalah j. Setelah itu, cukup lakukan Brute Force untuk mendapatkan jarak tembak masing-masing sudut, dan carilah yang terjauh.</p>
 </blockquote>

		
		
		<h4> OSN 2015:  Menyiram Sawah </h4>
		<blockquote> <p>Pertama-tama, kita buat matriks baru D dengan nilai D[i,j] = 1 jika petak pada baris i dan kolom j adalah petak dominan, dan 0 jika sebaliknya.  Untuk persoalan ini, kita akan memerlukan 6 varian dari matriks tersebut:</p>
<ol>
  <li>Petak yang dominan terhadap keempat tetangganya.</li>
  <li>Petak yang dominan terhadap seluruh tetangga kecuali petak di atasnya.</li>
  <li>Petak yang dominan terhadap seluruh tetangga kecuali petak di kirinya.</li>
  <li>Petak yang dominan terhadap seluruh tetangga kecuali petak di bawahnya.</li>
  <li>Petak yang dominan terhadap seluruh tetangga kecuali petak di kanannya.</li>
  <li>Petak yang dominan terhadap tetangga di kiri dan kanannya.</li>
</ol>

<p>Untuk masing-masing matriks, lakukan DP “Prefix sum 2D”. Dengan 6 tabel DP berbeda, anda bisa menjawab setiap query dengan kompleksitas O(1). Detilnya diserahkan kepada Anda untuk latihan.</p>
 </blockquote>

		

	

	
		<h3> Struktur Data Linear </h3>
		
		
		<h4> OSN 2013: Lipat Kertas </h4>
		<blockquote> <p>Sebuah lekukan dapat direpresentasikan sebagai interval dengan ujung-ujungnya adalah posisi kedua sisi warna pada tumpukan dalam lipatan kertas tersebut. Sebagai contoh lekukan ke-1 (sisi warna 1 dan sisi warna 2) memiliki representasi interval [1,8], dan lekukan ke-2 (sisi warna 2 dan sisi warna 3) memiliki rerpresentasi interval [8,5] atau [5,8]. Dengan begitu, persoalan ini dapat direpresentasikan sebagai soal “bracket matching”, atau pencocokan tanda kurung, persis dengan contoh soal di bab ini.</p>
 </blockquote>

		

	

      </div>
    </div>
  </body>
</html>
