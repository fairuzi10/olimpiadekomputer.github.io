<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="robots" content="noindex">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Heap &middot; Olimpiade Komputer
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- math functions -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body class="layout-reverse">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
  <h3> <a class="sidebar-item" href="/">Home</a></h3>
  <h3> <a class="sidebar-item" href="/algoritma">Algoritma</a></h3>
  <a class="sidebar-nav-item" href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html">Aritmetika dan aturan berhitung</a><ul><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#aritmetika-modular">Aritmetika modular </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#bilangan-prima">Bilangan prima </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#kpk-dan-fpb">KPK dan FPB </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#pigeonhole-principle">Pigeonhole Principle </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#aturan-perkalian-dan-penjumlahan">Aturan perkalian dan penjumlahan </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#permutasi-dan-kombinasi">Permutasi dan kombinasi </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#probabilitas">Probabilitas </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#prinsip-inklusi-dan-eksklusi">Prinsip Inklusi dan Eksklusi </li><li> <a href="/algoritma/Aritmetika-dan-Aturan-Berhitung/index.html#segitiga-pascal">Segitiga Pascal </li></ul><a class="sidebar-nav-item" href="/algoritma/Pengurutan-dan-Pencarian/index.html">Pengurutan dan Pencarian</a><ul><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#bubble-sort">Bubble Sort </li><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#insertion-sort">Insertion Sort </li><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#counting-sort">Counting Sort </li><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#merge-dan-quick-sort">Merge dan Quick Sort </li><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#linear-search">Linear Search </li><li> <a href="/algoritma/Pengurutan-dan-Pencarian/index.html#binary-search">Binary Search </li></ul><a class="sidebar-nav-item" href="/algoritma/Brute-Force/index.html">Brute Force</a><a class="sidebar-nav-item" href="/algoritma/Greedy/index.html">Greedy</a><a class="sidebar-nav-item" href="/algoritma/Dynamic-Programming/index.html">Dynamic Programming</a><a class="sidebar-nav-item" href="/algoritma/Struktur-Data-Linear/index.html">Struktur Data Linear</a><a class="sidebar-nav-item" href="/algoritma/Struktur-Data-Nonlinear/index.html">Heap</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2017. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Olimpiade Komputer</a>
            <small>Kurikulum OSN 2017</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
  <h1 class="page-title">Heap</h1>
  <h3 id="pendahuluan">Pendahuluan</h3>

<p>Melalui dokumen ini, kalian akan:</p>

<ul>
  <li>
    <p>Mengenal dan mengimplementasikan struktur data [[<strong>heap</strong>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Mengetahui mengapa diperlukan [[<strong>heap</strong>]<script type="math/tex">]</script></p>
  </li>
</ul>

<h3 id="motivasi">Motivasi</h3>

<p>Anda diberikan sejumlah operasi. Setiap operasi dapat berbentuk salah
satu dari:</p>

<ul>
  <li>
    <p>add(<script type="math/tex">x</script>): simpan bilangan <script type="math/tex">x</script>.</p>
  </li>
  <li>
    <p>getMax(): dapatkan bilangan terbesar yang saat ini masih disimpan.</p>
  </li>
  <li>
    <p>deleteMax(): hapus bilangan terbesar dari penyimpanan.</p>
  </li>
</ul>

<h3 id="motivasi-1">Motivasi</h3>

<p>Berikut contoh operasinya dan perilaku yang diharapkan:</p>

<ul>
  <li>
    <p>add(5), bilangan yang disimpan: [5].</p>
  </li>
  <li>
    <p>add(7), bilangan yang disimpan: [5, 7].</p>
  </li>
  <li>
    <p>add(3), bilangan yang disimpan: [5, 7, 3].</p>
  </li>
  <li>
    <p>getMax(), laporkan bahwa 7 merupakan bilangan terbesar.</p>
  </li>
  <li>
    <p>deleteMax(), bilangan yang disimpan: [5, 3].</p>
  </li>
  <li>
    <p>getMax(), laporkan bahwa 5 merupakan bilangan terbesar.</p>
  </li>
</ul>

<h3 id="solusi-sederhana">Solusi Sederhana</h3>

<ul>
  <li>
    <p>Solusi paling mudah adalah membuat sebuah [[<em>array</em>]<script type="math/tex">]</script>besar dan
variabel yang menunjukkan posisi terakhir elemen pada
[[<em>array</em>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Untuk setiap operasi add(<script type="math/tex">x</script>), tambahkan elemen [[<em>array</em>]<script type="math/tex">]</script>,
geser variabel penunjuk, lalu urutkan data.</p>
  </li>
  <li>
    <p>Operasi getMax() dapat dilayani dengan mengembalikan elemen
terbesar.</p>
  </li>
  <li>
    <p>Operasi deleteMax() dapat dilayani dengan menggeser variabel
penunjuk.</p>
  </li>
</ul>

<h3 id="analisis-solusi-sederhana">Analisis Solusi Sederhana</h3>

<ul>
  <li>
    <p>Misalkan <script type="math/tex">N</script> menyatakan banyaknya elemen pada [[<em>array</em>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Dengan cara ini, operasi add(<script type="math/tex">x</script>) berlangsung dalam <script type="math/tex">O(N \log{N})</script>,
apabila pengurutannya menggunakan [<strong>Quicksort</strong>]$$.</p>
  </li>
  <li>
    <p>Operasi getMax() dan deleteMax() berlangsung dalam <script type="math/tex">O(1)</script>.</p>
  </li>
  <li>
    <p>Perhatikan bahwa pengurutan akan lebih efisien jika digunakan
[<strong>Insertion Sort</strong>]<script type="math/tex">, sehingga kompleksitas add(</script>x<script type="math/tex">) menjadi</script>O(N)$$.</p>
  </li>
</ul>

<h3 id="analisis-solusi-sederhana-1">Analisis Solusi Sederhana</h3>

<p>Operasi        Dengan Sorting
  ————- —————-
  add(<script type="math/tex">x</script>)           <script type="math/tex">O(N)</script>
  getMax()           <script type="math/tex">O(1)</script>
  deleteMax()        <script type="math/tex">O(1)</script></p>

<h3 id="masalah-solusi-sederhana">Masalah Solusi Sederhana</h3>

<ul>
  <li>
    <p>Solusi sederhana ini tidak efisien ketika banyak dilakukan operasi
add(<script type="math/tex">x</script>).</p>
  </li>
  <li>
    <p>Kita akan mempelajari bagaimana [[<strong>heap</strong>]<script type="math/tex">]</script>mengatasi masalah
ini secara efisien.</p>
  </li>
</ul>

<h1 id="pengenalan-heap">Pengenalan Heap</h1>

<h3 id="heap">Heap</h3>

<ul>
  <li>
    <p>[[<strong>Heap</strong>]<script type="math/tex">]</script>merupakan struktur data yang umum dikenal pada ilmu
komputer.</p>
  </li>
  <li>
    <p>Nama [[<strong>heap</strong>]<script type="math/tex">]</script>sendiri berasal dari Bahasa Inggris, yang
berarti “gundukan”.</p>
  </li>
</ul>

<h3 id="operasi-heap">Operasi Heap</h3>

<p>[[<strong>Heap</strong>]<script type="math/tex">]</script>mendukung operasi:</p>

<ul>
  <li>
    <p>[<strong>Push</strong>]$$, yaitu memasukan elemen baru ke penyimpanan.</p>
  </li>
  <li>
    <p>[<strong>Pop</strong>]$$, yaitu membuang elemen <strong>terbesar</strong> dari penyimpanan.</p>
  </li>
  <li>
    <p>[<strong>Top</strong>]$$, yaitu mengakses elemen <strong>terbesar</strong> dari penyimpanan.</p>
  </li>
</ul>

<h3 id="cara-kerja-heap">Cara Kerja Heap</h3>

<ul>
  <li>
    <p>[[<strong>Heap</strong>]<script type="math/tex">]</script>dapat diimplementasikan dengan berbagai cara.</p>
  </li>
  <li>
    <p>Kita akan mempelajari salah satunya, yaitu [[<strong>Binary Heap</strong>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Sebelum itu, diperlukan pengetahuan mengenai [<strong>tree</strong>]$$.</p>
  </li>
</ul>

<h3 id="tree">Tree</h3>

<ul>
  <li>Seperti yang telah dipelajari, [[<em>tree</em>]<script type="math/tex">]</script>merupakan suatu
[[<em>graph</em>]<script type="math/tex">]</script>yang setiap [[<em>node</em>]<script type="math/tex">]</script>-nya saling terhubung dan
tidak memiliki [<em>cycle</em>]$$.</li>
</ul>

<p><img src="asset/tree.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="rooted-tree">Rooted Tree</h3>

<ul>
  <li>Suatu [[<em>tree</em>]<script type="math/tex">]</script>yang memiliki akar, atau [[<em>node</em>]<script type="math/tex">]</script>yang
berada di paling atas disebut sebagai [<em>rooted-tree</em>]$$.</li>
</ul>

<p><img src="asset/rooted-tree.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="binary-tree">Binary Tree</h3>

<ul>
  <li>Suatu [<em>rooted-tree</em>]<script type="math/tex">yang setiap [[*node*]</script>]<script type="math/tex">-nya memiliki 0,
1, atau 2 anak disebut dengan [*Binary Tree*]</script>.</li>
</ul>

<p><img src="asset/binary-tree.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="full-binary-tree">Full Binary Tree</h3>

<ul>
  <li>Suatu [<em>binary tree</em>]<script type="math/tex">yang seluruh [[*node*]</script>]<script type="math/tex">-nya memiliki 2
anak, kecuali tingkat paling bawah yang tidak memiliki anak, disebut
dengan [*Full Binary Tree*]</script></li>
</ul>

<p><img src="asset/full-binary-tree.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="complete-binary-tree">Complete Binary Tree</h3>

<p>[<em>Complete Binary Tree</em>]<script type="math/tex">adalah [*binary tree*]</script> yang:</p>

<ul>
  <li>
    <p>Seluruh [[<em>node</em>]<script type="math/tex">]</script>-nya memiliki 2 anak, kecuali tingkat paling
bawah.</p>
  </li>
  <li>
    <p>Tingkat paling bawahnya dapat terisi sebagian, tetapi harus terisi
dari kiri ke kanan.</p>
  </li>
</ul>

<p><img src="asset/complete-binary-tree.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="bukan-complete-binary-tree">Bukan Complete Binary Tree</h3>

<p>Berikut bukan [<em>Complete Binary Tree</em>]$$, sebab elemen di tingkat paling
bawah tidak berisi dari kiri ke kanan (terdapat lubang).</p>

<p><img src="asset/not-complete-binary-tree-1.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="bukan-complete-binary-tree-1">Bukan Complete Binary Tree</h3>

<p>Berikut juga bukan [<em>Complete Binary Tree</em>]<script type="math/tex">, sebab terdapat
[[*node*]</script>]$$tanpa 2 anak pada tingkat bukan paling bawah.</p>

<p><img src="asset/not-complete-binary-tree-2.pdf" alt="image" />{width=”7cm”}</p>

<h3 id="struktur-binary-heap">Struktur Binary Heap</h3>

<p>Struktur data [[<strong>binary heap</strong>]<script type="math/tex">]</script>memiliki sifat:</p>

<ul>
  <li>
    <p>Berstruktur [<em>complete binary tree</em>]$$.</p>
  </li>
  <li>
    <p>Setiap [[<em>node</em>]<script type="math/tex">]</script>merepresentasikan elemen yang disimpan pada
[[<strong>heap</strong>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Setiap [[<em>node</em>]<script type="math/tex">]</script>memiliki nilai yang <strong>lebih besar</strong> daripada
[[<em>node</em>]<script type="math/tex">]</script>anak-anaknya.</p>
  </li>
</ul>

<h3 id="contoh-binary-heap">Contoh Binary Heap</h3>

<p><img src="asset/heap.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="contoh-bukan-binary-heap">Contoh Bukan Binary Heap</h3>

<p>Bukan binary heap.</p>

<p><img src="asset/not-heap.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="mengapa-harus-demikian">Mengapa Harus Demikian?</h3>

<ul>
  <li>
    <p>Struktur seperti ini menjamin operasi-operasi yang dilayani
[[<strong>heap</strong>]<script type="math/tex">]</script>dapat dilakukan secara efisien.</p>
  </li>
  <li>
    <p>Misalkan <script type="math/tex">N</script> adalah banyaknya elemen yang sedang disimpan.</p>
  </li>
  <li>
    <p>Operasi [<strong>push</strong>]<script type="math/tex">dan [**pop**]</script> bekerja dalam <script type="math/tex">O(\log{N})</script>,
sementara [<strong>top</strong>]<script type="math/tex">bekerja dalam</script>O(1)$$.</p>
  </li>
  <li>
    <p>Kita akan melihat satu per satu bagaimana operasi tersebut
dilaksanakan.</p>
  </li>
</ul>

<h3 id="operasi-push">Operasi Push</h3>

<p>Melakukan [<em>push</em>]<script type="math/tex">pada [[**binary heap**]</script>]$$dilakukan dengan 2
tahap:</p>

<ul>
  <li>
    <p>Tambahkan [[<em>node</em>]<script type="math/tex">]</script>baru di posisi yang memenuhi aturan
[<em>complete binary tree</em>]$$.</p>
  </li>
  <li>
    <p>Selama elemen [[<em>node</em>]<script type="math/tex">]</script>yang merupakan orang tua langsung dari
elemen ini memiliki nilai yang lebih kecil, tukar nilai elemen kedua
[[<em>node</em>]<script type="math/tex">]</script>tersebut.</p>
  </li>
</ul>

<h3 id="operasi-push-1">Operasi Push</h3>

<p>Sebagai contoh, misalkan hendak ditambahkan elemen bernilai 8 ke suatu
[[<strong>binary heap</strong>]<script type="math/tex">]</script>berikut:</p>

<p><img src="asset/heap.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-push-lanj">Operasi Push (lanj.)</h3>

<p>Tambahkan [[<em>node</em>]<script type="math/tex">]</script>.</p>

<p><img src="asset/push-1.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-push-lanj-1">Operasi Push (lanj.)</h3>

<p>Karena orang tua-nya memiliki nilai lebih kecil, tukar nilainya.</p>

<p><img src="asset/push-2.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-push-lanj-2">Operasi Push (lanj.)</h3>

<p>Karena orang tua-nya masih memiliki nilai lebih kecil, tukar lagi.</p>

<p><img src="asset/push-3.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-push-lanj-3">Operasi Push (lanj.)</h3>

<p>Orang tua-nya sudah memiliki nilai yang lebih besar.Operasi push
selesai.</p>

<p><img src="asset/push-4.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop">Operasi Pop</h3>

<p>Melakukan [<em>pop</em>]<script type="math/tex">pada [[**binary heap**]</script>]$$dilakukan dengan 2
tahap:</p>

<ul>
  <li>
    <p>Tukar posisi elemen pada [<em>root</em>]<script type="math/tex">dengan elemen terakhir mengikuti
aturan [*complete binary tree*]</script>.</p>
  </li>
  <li>
    <p>Buang elemen terakhir [[<strong>binary heap</strong>]<script type="math/tex">]</script>, yang telah berisi
elemen dari [<em>root</em>]$$.</p>
  </li>
  <li>
    <p>Selama elemen yang ditukar ke posisi [<em>root</em>]$$ memiliki anak
langsung yang berelemen lebih besar, tukar elemen tersebut dengan
salah anaknya yang memiliki elemen <strong>terbesar</strong>.</p>
  </li>
</ul>

<h3 id="operasi-pop-lanj">Operasi Pop (lanj.)</h3>

<p>Misalkan akan dilakukan pop pada [[<strong>heap</strong>]<script type="math/tex">]</script>berikut:</p>

<p><img src="asset/pop-1.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop-lanj-1">Operasi Pop (lanj.)</h3>

<p>Tukar elemen pada [<em>root</em>]<script type="math/tex">dengan elemen terakhir pada [*complete
binary tree*]</script>.</p>

<p><img src="asset/pop-2.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop-lanj-2">Operasi Pop (lanj.)</h3>

<p>Buang elemen terakhir.</p>

<p><img src="asset/pop-3.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop-lanj-3">Operasi Pop (lanj.)</h3>

<p>Perbaiki struktur [[<strong>heap</strong>]<script type="math/tex">]</script>dengan menukar elemen pada [<em>root</em>]$$
dengan anaknya yang bernilai <strong>terbesar</strong>.</p>

<p><img src="asset/pop-4.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop-lanj-4">Operasi Pop (lanj.)</h3>

<p>Karena masih terdapat anaknya yang lebih besar, tukar lagi.</p>

<p><img src="asset/pop-5.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-pop-lanj-5">Operasi Pop (lanj.)</h3>

<p>Kini sudah tidak ada anak yang bernilai lebih besar, operasi pop
selesai.</p>

<p><img src="asset/pop-6.pdf" alt="image" />{width=”9cm”}</p>

<h3 id="operasi-top">Operasi Top</h3>

<ul>
  <li>
    <p>Operasi ini sebenarnya sesederhana mengembalikan elemen pada
[<em>root</em>]<script type="math/tex">[[**binary heap**]</script>]$$.</p>
  </li>
  <li>
    <p>Kompleksitas operasi ini adalah <script type="math/tex">O(1)</script>.</p>
  </li>
</ul>

<h3 id="analisis-solusi-dengan-heap">Analisis Solusi dengan Heap</h3>

<p>Penerapan [[<strong>heap</strong>]<script type="math/tex">]</script>pada persoalan motivasi:</p>

<p>Operasi        Dengan Sorting   Dengan Heap
  ————- —————- ————–
  add(<script type="math/tex">x</script>)           <script type="math/tex">O(N)</script>       <script type="math/tex">O(\log{N})</script>
  getMax()           <script type="math/tex">O(1)</script>          <script type="math/tex">O(1)</script>
  deleteMax()        <script type="math/tex">O(1)</script>       <script type="math/tex">O(\log{N})</script></p>

<p>Kini seluruh operasi dapat dilakukan dengan efisien.</p>

<h1 id="implementasi-binary-heap">Implementasi Binary Heap</h1>

<h3 id="membuat-tree">Membuat Tree</h3>

<ul>
  <li>
    <p>Representasi [[<em>tree</em>]<script type="math/tex">]</script>pada implementasi dapat menggunakan
teknik representasi [[<em>graph</em>]<script type="math/tex">]</script>yang telah dipelajari sebelumnya.</p>
  </li>
  <li>
    <p>Namun, untuk [[<em>tree</em>]<script type="math/tex">]</script>dengan kondisi tertentu, kita dapat
menggunakan representasi yang lebih sederhana.</p>
  </li>
  <li>
    <p>Terutama pada kasus ini, yang mana [[<em>tree</em>]<script type="math/tex">]</script>yang diperlukan
adalah [<em>complete binary tree</em>]$$.</p>
  </li>
</ul>

<h3 id="representasi-complete-binary-tree">Representasi Complete Binary Tree</h3>

<ul>
  <li>
    <p>Kedengarannya kurang masuk akal, tetapi [<em>complete binary tree</em>]<script type="math/tex">dapat direpresentasikan dengan sebuah [[*array*]</script>]$$.</p>
  </li>
  <li>
    <p>Misalkan [[<em>array</em>]<script type="math/tex">]</script>ini bersifat [<em>zero-based</em>]$$, yaitu dimulai
dari indeks 0.</p>
  </li>
  <li>
    <p>Elemen pada indeks ke-<script type="math/tex">i</script> menyatakan elemen pada
[[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">i</script>.</p>
  </li>
  <li>
    <p>Anak kiri dari [[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">i</script> adalah
[[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">(2i+1)</script>.</p>
  </li>
  <li>
    <p>Anak kanan dari [[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">i</script> adalah
[[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">(2i+2)</script>.</p>
  </li>
</ul>

<h3 id="representasi-complete-binary-tree-lanj">Representasi Complete Binary Tree (lanj.)</h3>

<p>TODO: GAMBAR REPRESENTASI ARRAY</p>

<h3 id="representasi-complete-binary-tree-lanj-1">Representasi Complete Binary Tree (lanj.)</h3>

<ul>
  <li>
    <p>Dengan logika yang serupa, orang tua dari [[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">i</script>
adalah [[<em>node</em>]<script type="math/tex">]</script>ke-<script type="math/tex">\lfloor\frac{i-1}{2}\rfloor</script></p>
  </li>
  <li>
    <p>Apabila Anda memutuskan untuk menggunakan [<em>one-based</em>]$$, berarti
rumusnya menjadi:</p>

    <ul>
      <li>
        <p>Anak kiri: <script type="math/tex">2i</script>.</p>
      </li>
      <li>
        <p>Anak kanan: <script type="math/tex">2i+1</script>.</p>
      </li>
      <li>
        <p>Orang tua: <script type="math/tex">\lfloor \frac{i}{2} \rfloor</script></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Representasi ini sangat mempermudah implementasi [[<strong>binary
heap</strong>]<script type="math/tex">]</script>.</p>
  </li>
</ul>

<h3 id="implementasi-push">Implementasi Push</h3>

<p>TODO</p>

<h3 id="implementasi-pop">Implementasi Pop</h3>

<p>TODO</p>

<h3 id="implementasi-top">Implementasi Top</h3>

<p>TODO</p>

<h3 id="catatan-implementasi">Catatan Implementasi</h3>

<ul>
  <li>
    <p>Tentu saja, Anda dapat membuat [[<strong>heap</strong>]<script type="math/tex">]</script>dengan urutan yang
terbalik, yaitu elemen terkecilnya di atas.</p>
  </li>
  <li>
    <p>Dengan demikian, operasi yang didukung adalah mencari atau menghapus
elemen terkecil.</p>
  </li>
  <li>
    <p>Biasanya [[<strong>heap</strong>]<script type="math/tex">]</script>dengan sifat ini disebut dengan
[<strong>min-heap</strong>]<script type="math/tex">, sementara [[**heap**]</script>]<script type="math/tex">dengan elemen terbesar
di atas disebut dengan [**max-heap**]</script>.</p>
  </li>
</ul>

<h3 id="manfaat-heap">Manfaat Heap</h3>

<ul>
  <li>
    <p>Pada ilmu komputer, [[<strong>heap</strong>]<script type="math/tex">]</script>dapat digunakan sebagai
<em>priority queue</em>, yaitu antrian yang terurut menurut suatu kriteria.</p>
  </li>
  <li>
    <p>Sifat [[<strong>heap</strong>]<script type="math/tex">]</script>juga dapat digunakan untuk optimisasi suatu
algoritma. Contoh paling nyatanya adalah untuk mempercepat algoritma
[<strong>Dijkstra</strong>]$$.</p>
  </li>
  <li>
    <p>Berbagai solusi persoalan [<strong>greedy</strong>]<script type="math/tex">juga dapat
diimplementasikan secara efisien dengan [[**heap**]</script>]$$.</p>
  </li>
</ul>

<h3 id="library-heap">Library Heap</h3>

<ul>
  <li>
    <p>Bagi pengguna C++, struktur data “priority_queue” dari include
algorithm merupakan struktur data [[<strong>heap</strong>]<script type="math/tex">]</script>.</p>
  </li>
  <li>
    <p>Bagi pengguna Pascal, Anda perlu mengimplementasikan
[[<strong>heap</strong>]<script type="math/tex">]</script>sendiri.</p>
  </li>
</ul>

<h3 id="penutup">Penutup</h3>

<ul>
  <li>TODO: kasih tau heapify gak diajarin</li>
</ul>


</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
    
  <div class="container content">
<hr>
Laman ini diurus oleh Ikatan Alumni Tim Olimpiade Komputer Indonesia (IA-TOKI)
<br>
<a href="https://github.com/olimpiadekomputer/olimpiadekomputer.github.io/issues"> Laporkan kekeliruan </a>
</div>
  </body>
</html>
